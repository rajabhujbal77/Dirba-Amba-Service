import { projectId, publicAnonKey } from '../../../utils/supabase/info';
import { createClient } from '@supabase/supabase-js';

// Create Supabase client
export const supabase = createClient(
  `https://${projectId}.supabase.co`,
  publicAnonKey
);

// Types matching the DB Schema (Simplified)
export type BookingStatus = 'booked' | 'loading' | 'in_transit' | 'reached_depot' | 'out_for_delivery' | 'delivered';
export type TripStatus = 'planned' | 'loading' | 'in_transit' | 'completed' | 'cancelled';

// Authentication
export const authApi = {
  async signUp(email: string, password: string, name: string, role: string, assignedDepotId?: string) {
    // 1. Create auth user
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email,
      password,
    });
    if (authError) throw authError;

    // 2. Create profile
    if (authData.user) {
      const { error: profileError } = await supabase.from('profiles').insert({
        id: authData.user.id, // Link to auth user
        email,
        full_name: name,
        role,
        assigned_depot_id: assignedDepotId || null,
        password // Storing for prototype compatibility
      });
      if (profileError) console.error('Error creating profile:', profileError);
    }
    return authData;
  },

  async signIn(email: string, password: string) {
    // Try authenticating with Supabase Auth first
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (!error && data.session) {
      // Fetch user profile to get role
      const profile = await this.getUserProfile(email);
      return {
        ...data,
        user: {
          ...data.user,
          role: profile?.role || 'owner'
        }
      };
    }

    // Fallback: Check manual profiles table
    const { data: profiles, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('email', email)
      .eq('password', password)
      .single();

    if (profileError || !profiles) throw new Error('Invalid login credentials');

    // Return mock session structure with role
    return {
      user: {
        id: profiles.id,
        email: profiles.email,
        role: profiles.role
      },
      session: { access_token: 'mock-token', user: profiles }
    };
  },

  async signOut() {
    await supabase.auth.signOut();
  },

  async getSession() {
    const { data } = await supabase.auth.getSession();
    return data.session;
  },

  async getUserProfile(email: string) {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('email', email)
      .single();

    if (error) return null;
    return data;
  }
};

// Bookings
export const bookingsApi = {
  async getAll() {
    const { data, error } = await supabase
      .from('bookings_complete')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) throw error;
    return { bookings: data };
  },

  async getById(id: string) {
    const { data, error } = await supabase
      .from('bookings')
      .select('*')
      .eq('id', id)
      .single();
    if (error) throw error;
    return { booking: data };
  },

  async create(bookingData: any) {
    try {
      // 1. Insert main booking record (receipt_number auto-generated by trigger)
      const { data: booking, error: bookingError } = await supabase
        .from('bookings')
        .insert({
          // receipt_number and id are auto-generated by trigger
          origin_depot_id: bookingData.origin_depot_id,
          destination_depot_id: bookingData.destination_depot_id,
          payment_method: bookingData.payment_method,
          delivery_type: bookingData.delivery_type,
          delivery_charges: bookingData.delivery_charges,
          sender_name: bookingData.sender_name,
          sender_phone: bookingData.sender_phone,
          subtotal: bookingData.subtotal,
          total_amount: bookingData.total_amount,
          status: bookingData.current_status || 'booked',
          custom_instructions: bookingData.special_instructions
        })
        .select()
        .single();

      if (bookingError) throw bookingError;

      // 2. Insert receivers
      const receivers = bookingData.receivers || [];
      for (let i = 0; i < receivers.length; i++) {
        const receiver = receivers[i];

        const { data: receiverData, error: receiverError } = await supabase
          .from('booking_receivers')
          .insert({
            booking_id: booking.id,
            receiver_name: receiver.name,
            receiver_phone: receiver.phone,
            delivery_address: receiver.address || null,
            receiver_order: i + 1
          })
          .select()
          .single();

        if (receiverError) throw receiverError;

        // 3. Insert packages for this receiver
        const packages = receiver.packages || [];
        for (const pkg of packages) {
          // Ensure package_id is null for custom packages or invalid values
          let validPackageId = null;
          if (pkg.packageId && pkg.packageId !== 'custom' && pkg.packageId.length > 10) {
            validPackageId = pkg.packageId;
          }

          const packageData = {
            receiver_id: receiverData.id,
            package_id: validPackageId,
            package_size: pkg.size || 'Custom',
            quantity: parseInt(String(pkg.quantity)) || 1,
            price_per_unit: parseFloat(String(pkg.price)) || 0,
            description: pkg.description || null
          };

          console.log('Inserting package:', packageData);

          const { error: packageError } = await supabase
            .from('receiver_packages')
            .insert(packageData);

          if (packageError) {
            console.error('Package insert error:', packageError, 'Data:', packageData);
            throw packageError;
          }
        }
      }

      return { booking };
    } catch (error) {
      console.error('Error creating booking:', error);
      throw error;
    }
  },

  async update(id: string, updates: any) {
    const { data, error } = await supabase
      .from('bookings')
      .update(updates)
      .eq('id', id)
      .select()
      .single();
    if (error) throw error;
    return { booking: data };
  },

  async updateStatus(id: string, status: string) {
    // Build update payload
    const updatePayload: any = { status };

    // If marking as delivered, also set delivered_at timestamp
    if (status === 'delivered') {
      updatePayload.delivered_at = new Date().toISOString();
    }

    const { data, error } = await supabase
      .from('bookings')
      .update(updatePayload)
      .eq('id', id)
      .select()
      .single();
    if (error) throw error;
    return { booking: data };
  },
};

// Trips
export const tripsApi = {
  async getAll() {
    const { data, error } = await supabase
      .from('trips')
      .select('*')
      .order('created_at', { ascending: false });
    if (error) {
      console.error('Trips getAll error:', error.code, error.message, error.details, error.hint);
      throw error;
    }
    return { trips: data || [] };
  },

  async create(tripData: any, bookingIds?: string[]) {
    const id = `TR-${Date.now().toString().slice(-8)}`;

    // Build insert object with only non-null values
    // Valid status values: 'planned', 'loading', 'in_transit', 'completed', 'cancelled'
    const insertData: any = {
      id,
      driver_name: tripData.driver,
      vehicle_number: tripData.vehicle,
      status: 'in_transit'
    };

    // Add optional fields only if they have values
    if (tripData.driverPhone) insertData.driver_phone = tripData.driverPhone;
    if (tripData.tripCost) insertData.trip_cost = tripData.tripCost;
    if (tripData.originId) insertData.origin_depot_id = tripData.originId;
    if (tripData.destinationId) insertData.destination_depot_id = tripData.destinationId;
    if (tripData.departure) insertData.departure_time = tripData.departure;
    if (tripData.eta) insertData.arrival_time = tripData.eta;

    const { data, error } = await supabase
      .from('trips')
      .insert(insertData)
      .select()
      .single();

    if (error) {
      console.error('Trip creation error - Code:', error.code);
      console.error('Trip creation error - Message:', error.message);
      console.error('Trip creation error - Details:', error.details);
      console.error('Trip creation error - Hint:', error.hint);
      console.error('Trip creation error - Insert data:', JSON.stringify(insertData, null, 2));
      throw error;
    }

    // Link bookings to this trip if bookingIds provided
    if (bookingIds && bookingIds.length > 0) {
      // Update bookings with trip_id and status
      const { error: bookingUpdateError } = await supabase
        .from('bookings')
        .update({
          trip_id: data.id,
          status: 'in_transit',
          current_location_depot_id: tripData.destinationId || null
        })
        .in('id', bookingIds);

      if (bookingUpdateError) {
        console.error('Error linking bookings to trip:', bookingUpdateError);
        // Don't throw - trip was created successfully
      }

      // Also populate trip_bookings junction table for querying
      const tripBookingsRows = bookingIds.map(bookingId => ({
        trip_id: data.id,
        booking_id: bookingId
      }));

      const { error: junctionError } = await supabase
        .from('trip_bookings')
        .insert(tripBookingsRows);

      if (junctionError) {
        console.error('Error inserting trip_bookings:', junctionError);
        // Don't throw - bookings are already linked via trip_id
      }
    }

    return { trip: data };
  },

  async update(id: string, updates: any) {
    const { data, error } = await supabase
      .from('trips')
      .update(updates)
      .eq('id', id)
      .select()
      .single();
    if (error) throw error;
    return { trip: data };
  },

  // Get all trips with their booking delivery progress
  async getAllWithProgress() {
    // Get all trips
    const { data: trips, error: tripsError } = await supabase
      .from('trips')
      .select('*')
      .order('created_at', { ascending: false });

    if (tripsError) throw tripsError;
    if (!trips || trips.length === 0) return { trips: [] };

    // Get booking counts per trip
    const { data: bookings, error: bookingsError } = await supabase
      .from('bookings')
      .select('trip_id, status')
      .not('trip_id', 'is', null);

    if (bookingsError) {
      console.error('Error fetching booking counts:', bookingsError);
      // Return trips without progress data
      return { trips: trips.map(t => ({ ...t, total_bookings: 0, delivered_bookings: 0 })) };
    }

    // Calculate progress per trip
    const tripProgress: Record<string, { total: number; delivered: number }> = {};
    (bookings || []).forEach((b: any) => {
      if (!tripProgress[b.trip_id]) {
        tripProgress[b.trip_id] = { total: 0, delivered: 0 };
      }
      tripProgress[b.trip_id].total++;
      if (b.status === 'delivered') {
        tripProgress[b.trip_id].delivered++;
      }
    });

    // Merge progress into trips
    const tripsWithProgress = trips.map(trip => ({
      ...trip,
      total_bookings: tripProgress[trip.id]?.total || 0,
      delivered_bookings: tripProgress[trip.id]?.delivered || 0
    }));

    return { trips: tripsWithProgress };
  },

  // Get all bookings for a specific trip
  async getBookingsForTrip(tripId: string) {
    const { data, error } = await supabase
      .from('bookings_complete')
      .select('*')
      .eq('trip_id', tripId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return { bookings: data || [] };
  },
};

// Users
export const usersApi = {
  async getAll() {
    const { data, error } = await supabase.from('profiles').select('*');
    if (error) throw error;
    const users = data.map(u => ({
      id: u.id,
      name: u.full_name,
      email: u.email,
      role: u.role,
      assignedDepot: u.assigned_depot_id,
      status: u.status
    }));
    return { users };
  },

  async create(userData: any) {
    const { data, error } = await supabase
      .from('profiles')
      .insert({
        email: userData.email,
        full_name: userData.name,
        role: userData.role,
        password: userData.password,
        assigned_depot_id: userData.assignedDepotId
      })
      .select()
      .single();
    if (error) throw error;
    return { user: data };
  },

  async update(id: string, updates: any) {
    const dbUpdates: any = {};
    if (updates.name) dbUpdates.full_name = updates.name;
    if (updates.role) dbUpdates.role = updates.role;
    if (updates.email) dbUpdates.email = updates.email;
    if (updates.assignedDepot) dbUpdates.assigned_depot_id = updates.assignedDepot;

    const { data, error } = await supabase
      .from('profiles')
      .update(dbUpdates)
      .eq('id', id)
      .select();
    if (error) throw error;
    return { user: data };
  },

  async delete(id: string) {
    const { error } = await supabase.from('profiles').delete().eq('id', id);
    if (error) throw error;
    return { success: true };
  },
};

// Depots
export const depotsApi = {
  async getAll() {
    const { data, error } = await supabase.from('depots').select('*').order('number');
    if (error) throw error;
    return { depots: data };
  },

  async create(depotData: any) {
    const { data, error } = await supabase
      .from('depots')
      .insert({
        name: depotData.name,
        type: depotData.type,
        location: depotData.address,
        contact_person: depotData.contactPerson,
        contact_phone: depotData.contactPhone
      })
      .select()
      .single();
    if (error) throw error;
    return { depot: data };
  },

  async update(id: string, updates: any) {
    const { data, error } = await supabase
      .from('depots')
      .update({
        name: updates.name,
        type: updates.type,
        location: updates.address,
        contact_person: updates.contactPerson,
        contact_phone: updates.contactPhone
      })
      .eq('id', id)
      .select();
    if (error) throw error;
    return { depot: data };
  },

  async delete(id: string) {
    const { error } = await supabase.from('depots').delete().eq('id', id);
    if (error) throw error;
    return { success: true };
  },
};

// Packages
export const packagesApi = {
  async getAll() {
    const { data, error } = await supabase.from('packages').select('*');
    if (error) throw error;
    const packages = data.map(p => ({
      id: p.id,
      name: p.name,
      basePrice: p.base_price
    }));
    return { packages };
  },

  async create(pkgData: any) {
    const { data, error } = await supabase
      .from('packages')
      .insert({
        name: pkgData.name,
        base_price: pkgData.basePrice
      })
      .select()
      .single();
    if (error) throw error;
    return { package: data };
  },

  async update(id: string, updates: any) {
    const { data, error } = await supabase
      .from('packages')
      .update({
        name: updates.name,
        base_price: updates.basePrice
      })
      .eq('id', id)
      .select();

    if (error) throw error;
    return { success: true };
  },

  async delete(id: string) {
    const { error } = await supabase.from('packages').delete().eq('id', id);
    if (error) throw error;
    return { success: true };
  }
};

// Depot Routes
export const depotRoutesApi = {
  async getAll() {
    const { data, error } = await supabase
      .from('depot_routes')
      .select(`
        *,
        origin_depot:origin_depot_id(name),
        forwarding_depot:forwarding_depot_id(name)
      `);
    if (error) throw error;

    // Transform flat rows into grouping expected by Settings UI
    // Group rows by origin_depot_id
    const groupedMap = new Map();

    data.forEach(row => {
      if (!groupedMap.has(row.origin_depot_id)) {
        groupedMap.set(row.origin_depot_id, {
          id: row.origin_depot_id, // Use origin ID as Group ID
          originDepotId: row.origin_depot_id,
          originDepotName: row.origin_depot?.name, // Helper for debug
          forwardingDepotIds: []
        });
      }
      groupedMap.get(row.origin_depot_id).forwardingDepotIds.push(row.forwarding_depot_id);
    });

    return { routes: Array.from(groupedMap.values()) };
  },

  async getByDepotId(depotId: string) {
    const { data, error } = await supabase
      .from('depot_routes')
      .select(`
        *,
        origin_depot:origin_depot_id(name),
        forwarding_depot:forwarding_depot_id(name)
      `)
      .eq('origin_depot_id', depotId);
    if (error) throw error;

    // Return list of forwarding depot IDs for this depot
    const forwardingDepotIds = data.map(row => row.forwarding_depot_id);
    return {
      depotId,
      forwardingDepotIds,
      routes: data
    };
  },

  async create(data: any) {
    // data = { originDepotId: '...', forwardingDepotIds: ['...', '...'] }
    const inserts = data.forwardingDepotIds.map((fId: string) => ({
      origin_depot_id: data.originDepotId,
      forwarding_depot_id: fId
    }));

    if (inserts.length > 0) {
      const { error } = await supabase.from('depot_routes').insert(inserts);
      if (error) throw error;
    }
    return { success: true };
  },

  async update(id: string, data: any) {
    // id here is the originDepotId (from our grouping)

    // 1. Delete existing routes for this origin
    await supabase.from('depot_routes').delete().eq('origin_depot_id', id);

    // 2. Insert new list
    const inserts = data.forwardingDepotIds.map((fId: string) => ({
      origin_depot_id: id,
      forwarding_depot_id: fId
    }));

    if (inserts.length > 0) {
      const { error } = await supabase.from('depot_routes').insert(inserts);
      if (error) throw error;
    }
    return { success: true };
  },

  async delete(id: string) {
    // id is originDepotId
    const { error } = await supabase.from('depot_routes').delete().eq('origin_depot_id', id);
    if (error) throw error;
    return { success: true };
  }
};

// Depot Pricing (Overrides)
export const depotPricingApi = {
  async getAll() {
    // Need a table for this: depot_package_prices
    const { data, error } = await supabase.from('depot_package_prices').select('*');
    if (error) {
      // If table doesn't exist yet (migration lag), return empty
      console.warn("depot_package_prices fetch failed", error);
      return { pricing: [] };
    }

    const pricing = data.map(p => ({
      id: p.id,
      depotId: p.depot_id,
      packageId: p.package_id,
      price: p.price
    }));
    return { pricing };
  },

  async update(packageId: string, depotId: string, price: number) {
    // Upsert
    const { error } = await supabase.from('depot_package_prices').upsert({
      package_id: packageId,
      depot_id: depotId,
      price: price
    }, { onConflict: 'depot_id, package_id' });

    if (error) throw error;
  }
};

// Season (Simple Settings)
export const seasonApi = {
  async get() {
    const { data } = await supabase.from('season_settings').select('*').limit(1).maybeSingle();
    return { season: data ? { startDate: data.start_date, endDate: data.end_date, year: 2025 } : null };
  },
  async update(data: any) {
    // Upsert logic. We need a fixed ID or singleton approach
    // First check if one exists
    const { data: existing } = await supabase.from('season_settings').select('id').limit(1).maybeSingle();

    if (existing) {
      await supabase.from('season_settings').update({
        start_date: data.startDate,
        end_date: data.endDate
      }).eq('id', existing.id);
    } else {
      await supabase.from('season_settings').insert({
        start_date: data.startDate,
        end_date: data.endDate
      });
    }
  }
};

// Receipts
export const receiptsApi = {
  ...bookingsApi,
  async getNextReceiptNumber() {
    const { data, error } = await supabase.rpc('get_next_receipt_number');
    if (error) throw error;
    return { receiptNumber: data };
  }
};

// Credit Ledger - Aggregates credit bookings and advance payments
export const creditApi = {
  // Get all credit bookings (payment_method = 'credit' or 'to_pay')
  async getCreditBookings() {
    const { data, error } = await supabase
      .from('bookings_complete')
      .select('*')
      .in('payment_method', ['credit', 'to_pay'])
      .order('created_at', { ascending: false });

    if (error) throw error;
    return { bookings: data || [] };
  },

  // Get all advance payments
  async getPayments(customerName?: string, customerPhone?: string) {
    let query = supabase
      .from('credit_payments')
      .select('*')
      .order('payment_date', { ascending: false });

    if (customerName && customerPhone) {
      query = query.eq('customer_name', customerName).eq('customer_phone', customerPhone);
    }

    const { data, error } = await query;
    if (error) throw error;
    return { payments: data || [] };
  },

  // Record a new advance payment
  async recordPayment(payment: {
    customer_name: string;
    customer_phone: string;
    amount: number;
    payment_method?: string;
    notes?: string;
  }) {
    const { data, error } = await supabase
      .from('credit_payments')
      .insert({
        customer_name: payment.customer_name,
        customer_phone: payment.customer_phone,
        amount: payment.amount,
        payment_method: payment.payment_method || 'cash',
        notes: payment.notes || ''
      })
      .select()
      .single();

    if (error) throw error;
    return { payment: data };
  },

  // Get credit summary aggregated by sender with advance payments
  async getCreditSummary() {
    // Fetch credit bookings
    const { data: bookings, error: bookingsError } = await supabase
      .from('bookings_complete')
      .select('*')
      .in('payment_method', ['credit', 'to_pay'])
      .order('created_at', { ascending: false });

    if (bookingsError) throw bookingsError;

    // Fetch all advance payments
    const { data: payments, error: paymentsError } = await supabase
      .from('credit_payments')
      .select('*')
      .order('payment_date', { ascending: false });

    // If payments table doesn't exist yet, just use empty array
    const allPayments = paymentsError ? [] : (payments || []);
    const allBookings = bookings || [];

    // Aggregate by sender_name only (normalized to lowercase for matching)
    const accountsMap = new Map<string, any>();

    // Process bookings
    allBookings.forEach((b: any) => {
      const name = (b.sender_name || 'Unknown').trim();
      const key = name.toLowerCase();

      if (!accountsMap.has(key)) {
        accountsMap.set(key, {
          id: key,
          customer: name,
          phone: b.sender_phone || 'N/A',
          totalCredit: 0,
          advancePaid: 0,
          netOutstanding: 0,
          lastPayment: null,
          bookings: [],
          payments: [],
          bookingCount: 0
        });
      }

      const account = accountsMap.get(key);
      const amount = Number(b.total_amount) || 0;

      // Update phone if account has N/A but booking has phone
      if (account.phone === 'N/A' && b.sender_phone) {
        account.phone = b.sender_phone;
      }

      account.totalCredit += amount;
      account.bookingCount += 1;
      account.bookings.push({
        id: b.id || b.receipt_number,
        receiptNumber: b.receipt_number,
        amount: amount,
        date: b.created_at,
        status: b.status,
        destination: b.destination_depot_name || 'N/A'
      });
    });

    // Process payments - match by customer name only
    allPayments.forEach((p: any) => {
      const name = (p.customer_name || 'Unknown').trim();
      const key = name.toLowerCase();

      if (accountsMap.has(key)) {
        const account = accountsMap.get(key);
        const amount = Number(p.amount) || 0;

        // Update phone if we have it from payment
        if (account.phone === 'N/A' && p.customer_phone) {
          account.phone = p.customer_phone;
        }

        account.advancePaid += amount;
        account.payments.push({
          id: p.id,
          receiptNumber: p.receipt_number,
          amount: amount,
          date: p.payment_date,
          method: p.payment_method,
          notes: p.notes
        });

        if (!account.lastPayment || new Date(p.payment_date) > new Date(account.lastPayment)) {
          account.lastPayment = p.payment_date;
        }
      }
    });

    // Calculate net outstanding for each account
    accountsMap.forEach((account) => {
      account.netOutstanding = Math.max(0, account.totalCredit - account.advancePaid);
    });

    // Calculate totals
    const totalCredit = allBookings.reduce((sum: number, b: any) => sum + (Number(b.total_amount) || 0), 0);
    const totalAdvancePaid = allPayments.reduce((sum: number, p: any) => sum + (Number(p.amount) || 0), 0);
    const totalNetOutstanding = Math.max(0, totalCredit - totalAdvancePaid);

    return {
      accounts: Array.from(accountsMap.values()),
      totalCredit,
      totalAdvancePaid,
      totalNetOutstanding
    };
  }
};

// Backup
export const backupApi = {
  async create() { alert("Database usage active. Contact admin for SQL Dumps."); },
  async restore() { alert("Database usage active. Contact admin for SQL Restores."); }
};

// Contacts API for autocomplete
export const contactsApi = {
  // Search contacts by name or phone
  async search(query: string, limit: number = 10) {
    if (!query || query.length < 2) return { contacts: [] };

    const { data, error } = await supabase
      .from('contacts')
      .select('*')
      .or(`name.ilike.%${query}%,phone.ilike.%${query}%`)
      .order('usage_count', { ascending: false })
      .order('last_used_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error searching contacts:', error);
      return { contacts: [] };
    }

    return { contacts: data || [] };
  },

  // Get all contacts (for initial load if needed)
  async getAll(limit: number = 50) {
    const { data, error } = await supabase
      .from('contacts')
      .select('*')
      .order('usage_count', { ascending: false })
      .order('last_used_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error fetching contacts:', error);
      return { contacts: [] };
    }

    return { contacts: data || [] };
  },

  // Create or update a contact (upsert)
  async upsert(name: string, phone: string) {
    if (!name || !phone) return null;

    const { data, error } = await supabase
      .rpc('upsert_contact', { p_name: name, p_phone: phone });

    if (error) {
      console.error('Error upserting contact:', error);
      // Fallback to direct insert/update
      const { data: fallbackData, error: fallbackError } = await supabase
        .from('contacts')
        .upsert(
          { name, phone, usage_count: 1, last_used_at: new Date().toISOString() },
          { onConflict: 'phone' }
        )
        .select()
        .single();

      if (fallbackError) {
        console.error('Fallback upsert failed:', fallbackError);
        return null;
      }
      return fallbackData;
    }

    return data;
  }
};

// Reports API - Analytics and aggregations
export const reportsApi = {
  // Get booking summary with optional date range
  async getBookingSummary(fromDate?: string, toDate?: string) {
    let query = supabase
      .from('bookings_complete')
      .select('*');

    if (fromDate) {
      query = query.gte('created_at', fromDate);
    }
    if (toDate) {
      query = query.lte('created_at', toDate + 'T23:59:59');
    }

    const { data, error } = await query;
    if (error) throw error;

    const bookings = data || [];

    // Count by status
    const totalBookings = bookings.length;
    const bookedCount = bookings.filter(b => b.status === 'booked').length;
    const inTransitCount = bookings.filter(b => ['in_transit', 'in_transit_origin', 'in_transit_forwarding'].includes(b.status)).length;
    const deliveredCount = bookings.filter(b => b.status === 'delivered').length;
    const pendingCount = bookedCount + inTransitCount; // Not yet delivered

    // Revenue calculation
    const totalRevenue = bookings.reduce((sum, b) => sum + (Number(b.total_amount) || 0), 0);

    // Package count
    const totalPackages = bookings.reduce((sum, b) => {
      if (Array.isArray(b.package_details)) {
        return sum + b.package_details.reduce((pSum: number, pkg: any) => pSum + (Number(pkg.quantity) || 0), 0);
      }
      return sum;
    }, 0);

    // Revenue by payment method
    const revenueByMethod = {
      cash: bookings.filter(b => b.payment_method === 'cash').reduce((s, b) => s + (Number(b.total_amount) || 0), 0),
      online: bookings.filter(b => b.payment_method === 'online').reduce((s, b) => s + (Number(b.total_amount) || 0), 0),
      to_pay: bookings.filter(b => b.payment_method === 'to_pay').reduce((s, b) => s + (Number(b.total_amount) || 0), 0),
      credit: bookings.filter(b => b.payment_method === 'credit').reduce((s, b) => s + (Number(b.total_amount) || 0), 0),
    };

    return {
      totalBookings,
      bookedCount,
      inTransitCount,
      deliveredCount,
      pendingCount,
      totalRevenue,
      totalPackages,
      revenueByMethod
    };
  },

  // Get trip summary
  async getTripSummary(fromDate?: string, toDate?: string) {
    let query = supabase
      .from('trips')
      .select('*');

    if (fromDate) {
      query = query.gte('created_at', fromDate);
    }
    if (toDate) {
      query = query.lte('created_at', toDate + 'T23:59:59');
    }

    const { data, error } = await query;
    if (error) throw error;

    const trips = data || [];

    const totalTrips = trips.length;
    const completedTrips = trips.filter(t => t.status === 'completed').length;
    const activeTrips = trips.filter(t => t.status === 'active' || t.status === 'in_transit').length;
    const totalTripCost = trips.reduce((sum, t) => sum + (Number(t.trip_cost) || 0), 0);

    return {
      totalTrips,
      completedTrips,
      activeTrips,
      pendingTrips: totalTrips - completedTrips - activeTrips,
      totalTripCost
    };
  },

  // Get top customers by revenue
  async getTopCustomers(limit: number = 5, fromDate?: string, toDate?: string) {
    let query = supabase
      .from('bookings_complete')
      .select('sender_name, sender_phone, total_amount');

    if (fromDate) {
      query = query.gte('created_at', fromDate);
    }
    if (toDate) {
      query = query.lte('created_at', toDate + 'T23:59:59');
    }

    const { data, error } = await query;
    if (error) throw error;

    const bookings = data || [];

    // Aggregate by sender
    const customerMap = new Map<string, { name: string; phone: string; bookings: number; revenue: number }>();

    bookings.forEach(b => {
      const key = (b.sender_name || 'Unknown').toLowerCase().trim();
      if (!customerMap.has(key)) {
        customerMap.set(key, {
          name: b.sender_name || 'Unknown',
          phone: b.sender_phone || 'N/A',
          bookings: 0,
          revenue: 0
        });
      }
      const customer = customerMap.get(key)!;
      customer.bookings += 1;
      customer.revenue += Number(b.total_amount) || 0;
    });

    // Sort by revenue and take top N
    const topCustomers = Array.from(customerMap.values())
      .sort((a, b) => b.revenue - a.revenue)
      .slice(0, limit);

    return { customers: topCustomers };
  },

  // Get top routes by revenue
  async getTopRoutes(limit: number = 5, fromDate?: string, toDate?: string) {
    let query = supabase
      .from('bookings_complete')
      .select('origin_depot_name, destination_depot_name, total_amount');

    if (fromDate) {
      query = query.gte('created_at', fromDate);
    }
    if (toDate) {
      query = query.lte('created_at', toDate + 'T23:59:59');
    }

    const { data, error } = await query;
    if (error) throw error;

    const bookings = data || [];

    // Aggregate by route
    const routeMap = new Map<string, { route: string; trips: number; revenue: number }>();

    bookings.forEach(b => {
      const origin = b.origin_depot_name || 'Unknown';
      const destination = b.destination_depot_name || 'Unknown';
      const key = `${origin} â†’ ${destination}`;

      if (!routeMap.has(key)) {
        routeMap.set(key, { route: key, trips: 0, revenue: 0 });
      }
      const route = routeMap.get(key)!;
      route.trips += 1;
      route.revenue += Number(b.total_amount) || 0;
    });

    // Sort by revenue and take top N
    const topRoutes = Array.from(routeMap.values())
      .sort((a, b) => b.revenue - a.revenue)
      .slice(0, limit);

    return { routes: topRoutes };
  }
};